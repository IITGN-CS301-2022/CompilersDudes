from dataclasses import dataclass
from fractions import Fraction
from typing import Union, Mapping  #Union is used to specify that a variable can have one of several types and Mapping is a type hint for dictionaries or mappings.

@dataclass
#  The _init_ method takes any number of arguments and passes them to the Fraction constructor to create a new Fraction object, which is then stored in the value field.
class NumLiteral:
    value: Fraction
    def __init__(self, *args):
        self.value = Fraction(*args)

@dataclass
# this is kind of binary operation
class BinOp:                      
    operator: str      # '+' is the operator in addition
    # below are kind of two no. to be added
    left: 'AST'
    right: 'AST'

@dataclass
class Variable:
    name: str

@dataclass
class Let:
    var: 'AST'
    e1: 'AST'
    e2: 'AST'

@dataclass
class BoolLiteral:
    value: bool

@dataclass
class if_else:
    expr: 'AST'
    et: 'AST'    #statement if expr is true
    ef: 'AST'    #statement if expr is false

@dataclass
class Assign:
    var: 'AST'
    expr: 'AST'

@dataclass
class Get:
    var: 'AST'

@dataclass
class while_loop:
    condition: 'AST'
    body: 'AST'


@dataclass
class for_loop:
    var: 'AST'
    start_expr: 'AST'
    end_expr: 'AST'
    condition: 'AST'
    body: 'AST'
    
@dataclass
class Two_Str_concatenation:
    str1: 'AST'
    str2: 'AST'

@dataclass
class LetMut:
    var: 'AST'
    e1: 'AST'
    e2: 'AST'


# The AST type is defined as a union of several classes, including NumLiteral, BinOp, Variable, Let, and If_else.
AST = NumLiteral | BinOp | Variable | Let  

Value = Fraction

# The InvalidProgram exception is defined. This exception will be raised when an invalid program is encountered during evaluation.
class InvalidProgram(Exception):
    pass

# environment is a mapping of variable names to their values and is used to keep track of the state of the program during evaluation. 
# The function returns the final value of the program.
def eval(program: AST, environment: Mapping[str, Value] = None) -> Value:
    if environment is None:
        environment = {}
    match program:
        case NumLiteral(value):
            return value
        case BoolLiteral(value):
            return value
        case Variable(name):
            if name in environment:
                return environment[name]
            raise InvalidProgram()
        case Let(Variable(name), e1, e2):
            v1 = eval(e1, environment)
            return eval(e2, environment | { name: v1 })
        case Two_Str_concatenation(str1,str2):
            result_str = eval(str1,environment) + eval(str2,environment)
            return result_str
        case Assign(Variable(name),expr):
            environment[name] = eval(expr,environment)
            return environment[name]
        case Get(Variable(name)):
            return environment[name]
        case BinOp("+", left, right):
            return eval(left, environment) + eval(right, environment)
        case BinOp("-", left, right):
            return eval(left, environment) - eval(right, environment)
        case BinOp("*", left, right):
            return eval(left, environment) * eval(right, environment)
        case BinOp("/", left, right):
            return eval(left, environment) / eval(right, environment)
        case BinOp(">",left,right):
            return BinOp(left,environment) > BinOp(right,environment)
        case if_else(expr,et,ef):
            v1 = eval(expr, environment)
            if v1 == True:
                return eval(et,environment)
            else:
                return eval(ef,environment)
        case while_loop(condition,body):
            v1 = eval(condition,environment)
            if v1 == True:
                eval(body,environment) 
                while_loop(condition,environment)
            return None
        case LetMut(Variable(name),e1,e2):
            v1 = eval(e1,environment)
            return eval(e2,environment | {name : v1})
    raise InvalidProgram()

def test_eval():
    e1 = NumLiteral(2)
    e2 = NumLiteral(7)
    e3 = NumLiteral(9)
    e4 = NumLiteral(5)
    e5 = BinOp("+", e2, e3)      
    e6 = BinOp("/", e5, e4)
    e7 = BinOp("*", e1, e6)
    assert eval(e7) == Fraction(32, 5)

def test_let_eval():
    a  = Variable("a")
    e1 = NumLiteral(5)
    e2 = BinOp("+", a, a)
    e  = Let(a, e1, e2)
    assert eval(e) == 10
    e  = Let(a, e1, Let(a, e2, e2))
    assert eval(e) == 20
    e  = Let(a, e1, BinOp("+", a, Let(a, e2, e2)))
    assert eval(e) == 25
    e  = Let(a, e1, BinOp("+", Let(a, e2, e2), a))
    assert eval(e) == 25
    e3 = NumLiteral(6); 
    e  = BinOp("+", Let(a, e1, e2), Let(a, e3, e2))
    assert eval(e) == 22

def test_letmut():
    # a = Variable("a")
    b = Variable("b")
    e1 = LetMut(b, NumLiteral(2), Assign(b, BinOp("+", NumLiteral(1), Get(b))))
    # e2 = LetMut(a, NumLiteral(1), Seq([e1, Get(a)]))
    assert eval(e1) == 3


# def test_while_eval():
#     a = Variable("a")
#     e1 = LetMut(a, NumLiteral(2), while_loop(Assign(a, BinOp("+", Get(a), NumLiteral(2)))) )
#     assert eval()

    
